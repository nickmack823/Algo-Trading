#!/usr/bin/env python3
"""
Merge generated indicator parts into 3 monolithic files:
- combined_calcs.py      (all *_calc.py functions/modules)
- combined_signals.py    (all *_signal.py functions/modules)
- combined_configs.json  (all *_config.py JSON objects merged into one dict)

Usage:
  python merge_indicators.py \
    --src scripts/generated_indicators \
    --out-calcs scripts/generated_indicators/combined_calcs.py \
    --out-signals scripts/generated_indicators/combined_signals.py \
    --out-configs scripts/generated_indicators/combined_configs.json
"""
from __future__ import annotations

import argparse
import json
import re
from pathlib import Path
from typing import Iterable

IMPORT_RE = re.compile(
    r"^\s*(?:from\s+\S+\s+import\s+.+|import\s+.+)\s*$", re.MULTILINE
)
MAIN_BLOCK_RE = re.compile(
    r'if\s+__name__\s*==\s*[\'"]__main__[\'"]\s*:\s*\n(?:\s+.+\n?)*', re.MULTILINE
)


def read_text(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="replace")


def extract_imports_and_body(code: str) -> tuple[list[str], str]:
    """Return (imports, body_without_imports_or___main__)."""
    imports = IMPORT_RE.findall(code)
    body = IMPORT_RE.sub("", code)
    body = MAIN_BLOCK_RE.sub("", body)
    return [i.strip() for i in imports], body.strip() + (
        "\n" if not code.endswith("\n") else ""
    )


def uniq(seq: Iterable[str]) -> list[str]:
    seen, out = set(), []
    for s in seq:
        if s not in seen:
            seen.add(s)
            out.append(s)
    return out


def collect_files(src: Path, suffix: str) -> list[Path]:
    return sorted([p for p in src.glob(f"*{suffix}.py") if p.is_file()])


def consolidate_py(files: list[Path], header_banner: str, extra_top: str = "") -> str:
    all_imports: list[str] = []
    bodies: list[str] = []
    for fp in files:
        code = read_text(fp)
        imports, body = extract_imports_and_body(code)
        all_imports.extend(imports)
        bodies.append(f"# === BEGIN {fp.name} ===\n{body}\n# === END {fp.name} ===\n")
    # de-dup imports; keep deterministic order
    all_imports = uniq(all_imports)
    # Some files import their siblings; in the combined files that’s redundant.
    # We can strip imports that bring in other *_calc or *_signal modules.
    all_imports = [im for im in all_imports if not re.search(r"(_calc|_signal)\b", im)]
    banner = f"# Auto-generated by merge_indicators.py\n# {header_banner}\n\n"
    top = (extra_top + "\n") if extra_top else ""
    out = (
        banner
        + ("\n".join(all_imports) + "\n\n" if all_imports else "")
        + top
        + "\n".join(bodies)
    )
    return out


def consolidate_configs_raw(files: list[Path]) -> str:
    """
    Concatenate the *raw text* of each *_config.py file into one file.
    No parsing, no validation—just verbatim content with clear separators.
    """
    chunks = []
    for fp in files:
        raw = read_text(fp)
        chunks.append(
            f"# === BEGIN {fp.name} ===\n{raw.rstrip()}\n# === END {fp.name} ===\n"
        )
    return "\n".join(chunks) + "\n"


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--src",
        default="scripts/generated_indicators",
        help="Folder containing *_calc.py, *_signal.py, *_config.py",
    )
    ap.add_argument(
        "--out-calcs", default="scripts/generated_indicators/combined_calcs.py"
    )
    ap.add_argument(
        "--out-signals", default="scripts/generated_indicators/combined_signals.py"
    )
    ap.add_argument(
        "--out-configs", default="scripts/generated_indicators/combined_configs.json"
    )
    args = ap.parse_args()

    src = Path(args.src)
    if not src.exists():
        raise SystemExit(f"Source folder not found: {src}")

    calc_files = collect_files(src, "_calc")
    signal_files = collect_files(src, "_signal")
    config_files = collect_files(src, "_config")

    # ---- CALCS
    calcs_code = consolidate_py(
        calc_files,
        header_banner="Combined indicator calculation functions",
        extra_top="""
# Shared imports that many calc files expect to exist:
import numpy as np
import pandas as pd
""",
    )
    Path(args.out_calcs).write_text(calcs_code, encoding="utf-8")
    print(f"Wrote {args.out_calcs}  ({len(calc_files)} files merged)")

    # ---- SIGNALS
    # Give signals access to the calcs with a single import-all (they often expect those symbols to exist).
    signals_code = consolidate_py(
        signal_files,
        header_banner="Combined indicator signal functions",
        extra_top="from .combined_calcs import *  # If used as a package\ntry:\n    from combined_calcs import *  # If run as flat files\nexcept Exception:\n    pass\n",
    )
    Path(args.out_signals).write_text(signals_code, encoding="utf-8")
    print(f"Wrote {args.out_signals}  ({len(signal_files)} files merged)")

    # ---- CONFIGS (raw text dump, no JSON)
    merged_raw = consolidate_configs_raw(config_files)
    Path(args.out_configs).write_text(merged_raw, encoding="utf-8")
    print(
        f"Wrote {args.out_configs}  ({len(config_files)} configs concatenated as raw text)"
    )


if __name__ == "__main__":
    main()
